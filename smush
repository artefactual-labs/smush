#!/usr/bin/env python

from __future__ import print_function
import subprocess
import sys
import app
import git_log_style_checker
import github
import topicmerge


def display_unmerged_commits(g, dev_branch):
    print()
    print(g.log('..{}'.format(dev_branch)))
    print()


def display_commit_style_errors(g, dev_branch):
    log_output = g.log("..{}".format(dev_branch))
    parsed_log = git_log_style_checker.parse_and_check_git_log_output(log_output)

    errors_found = False
    for commit in parsed_log:
        if "errors" in commit and len(commit["errors"]):
            errors_found = True

            print("Style error(s) found in commit {}:".format(commit["hash"]))
            print()

            for line in commit["errors"]:
                print("    {}".format(line))

            print()

    if not errors_found:
        print("No style errors found.")


def checkout_base_branch_and_check_dev_branch(g, base_branch, dev_branch, skip_style_check=False):
    g.checkout(base_branch)

    # Determine number of new commits and offer to rebase if greater than one
    number_of_unmerged_commits = int(g.rev_list('--count', base_branch + '..' + dev_branch))
    if number_of_unmerged_commits > 1:
        display_unmerged_commits(g, dev_branch)

        print('There is more than one new commit present in dev branch.')
        if app.get_confirmation('Would you like to interactively rebase?'):
            g.checkout(dev_branch)
            subprocess.call(['git', 'rebase', '-i', 'HEAD~' + str(number_of_unmerged_commits)])
            print('Updating dev branch...')
            g.push('--force')
            g.checkout(base_branch)
    elif number_of_unmerged_commits == 0:
        app.abort('No unmerged commits found.')

    # Display unmerged commits in dev branch
    display_unmerged_commits(g, dev_branch)

    # Show commit style errors
    if not skip_style_check:
        display_commit_style_errors(g, dev_branch)


def main():
    # Parse CLI args and load configuration
    args = app.arg_parser().parse_args()
    config = app.load_config(args.profile)

    # Set QA branch name from config and create git repository handler
    base_branch = config['base branch']

    try:
        merge = topicmerge.TopicMerge(base_branch, args.dev_branch)
    except Exception, e:
        app.abort(str(e))

    # Check branch and exit, if in --check mode
    if args.check:
        current_branch = merge.active_branch()
        checkout_base_branch_and_check_dev_branch(merge.g, base_branch, args.dev_branch, args.skip_style_check)
        merge.g.checkout(current_branch)
        sys.exit(0)

    # Make sure an open pull request exists for the dev branch
    if 'github owner' in config and 'github repo' in config and not args.skip_pr_check:
        github.check_for_valid_pull_request(config, base_branch, args.dev_branch)

    # Show "before notes" from config, if any
    if 'before notes' in config:
        print(config['before notes'])

    merge.rebase_topic_branch()

    # Do actual merge (with fast forward option as dev branch is rebased)
    print('Checking QA branch...')
    checkout_base_branch_and_check_dev_branch(merge.g, base_branch, args.dev_branch)

    # Merge or abort
    if not app.get_confirmation('Would you like to merge the above commits?'):
        g.checkout(args.dev_branch)
        app.abort('Merge aborted.')

    merge.merge_and_cleanup()

    # Optionally delete local dev branch
    if args.delete_local:
        print('Deleting local dev branch.')
        merge.g.branch('-D', args.dev_branch)

    print('Done!')

    # Show "after notes" from config, if any
    if 'after notes' in config:
        print(config['after notes'])


if __name__ == '__main__':
    main()
