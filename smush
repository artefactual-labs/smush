#!/usr/bin/env python

from __future__ import print_function
from builtins import input
import argparse
import git
import json
import os
import subprocess
import sys
import urllib2
import yaml


def load_config(config_filename):
    config_path = os.path.join(os.path.expanduser('~'), config_filename)
    return yaml.safe_load(open(config_path))


def abort(error_message):
    print(error_message)
    sys.exit(1)


def get_confirmation(prompt):
    confirm = input('{} [y/n] '.format(prompt))
    return len(confirm) and confirm[0].lower() == 'y'


def check_if_open_pull_request_exists_for_branch(owner, repo, branch):
    pr_url = 'https://api.github.com/repos/{}/{}/pulls?state=open'.format(owner, repo)
    unparsed_result = urllib2.urlopen(pr_url).read()
    pull_requests = json.loads(unparsed_result)

    for pr in pull_requests:
        if pr['head']['ref'] == branch:
            return True


def display_unmerged_commits(g, dev_branch):
    print()
    print(g.log('..{}'.format(dev_branch)))
    print()


def parse_and_check_git_log_output(log):
    commits = []
    commit = {}
    blank_lines = 0

    for line in log.split("\n"):
        if line.startswith("commit "):
            # Note errors, append commit, reset bookkeeping variables
            if commit != {}:
                check_commit_and_note_style_errors(commit)
                commits.append(commit)
                commit = {}
                blank_lines = 0
            commit["hash"] = line.replace("commit ", "")
        elif line.startswith("Author: "):
            commit["author"] = line.replace("Author: ", "")
        elif line.startswith("Date:   "):
            commit["date"] = line.replace("Date:   ", "")
        elif "body" not in commit and line.strip() != "":
            commit["header"] = line[4:]
            commit["body"] = []
        elif line.strip() != "":
            # Note if body line appears too early
            if blank_lines == 1:
                commit["no blank line before body"] = True
            commit["body"].append(line[4:])
        else:
            blank_lines += 1

    if commit != {}:
        check_commit_and_note_style_errors(commit)
        commits.append(commit)

    return commits


def check_commit_and_note_style_errors(commit):
    errors = []

    # Check header
    if len(commit["header"]) > 50:
        errors.append("Subject line exceeds 50 characters.")

    # Check if body occurs directly after header
    if "no blank line before body" in commit:
        errors.append("If multi-line, needs blank line after subject line.")

    # Check lines
    line_number = 1
    for line in commit["body"]:
        if len(line) > 72:
            errors.append("Body line {} exceeds 72 characters.".format(line_number))
        line_number += 1

    # Add any errors to commit and append
    if len(errors):
        commit["errors"] = errors


def display_commit_style_errors(g, dev_branch):
    log_output = g.log("..{}".format(dev_branch))
    parsed_log = parse_and_check_git_log_output(log_output)

    errors_found = False
    for commit in parsed_log:
        if "errors" in commit and len(commit["errors"]):
            errors_found = True

            print("Style error(s) found in commit {}:".format(commit["hash"]))
            print()

            for line in commit["errors"]:
                print("    {}".format(line))

            print()

    if not errors_found:
        print("No style errors found.")


def checkout_qa_branch_and_check_dev_branch(g, qa_branch, dev_branch, skip_style_check=False):
    g.checkout(qa_branch)

    # Determine number of new commits and offer to rebase if greater than one
    number_of_unmerged_commits = int(g.rev_list('--count', qa_branch + '..' + dev_branch))
    if number_of_unmerged_commits > 1:
        display_unmerged_commits(g, dev_branch)

        print('There is more than one new commit present in dev branch.')
        if get_confirmation('Would you like to interactively rebase?'):
            g.checkout(dev_branch)
            subprocess.call(['git', 'rebase', '-i', 'HEAD~' + str(number_of_unmerged_commits)])
            print('Updating dev branch...')
            g.push('--force')
            g.checkout(qa_branch)
    elif number_of_unmerged_commits == 0:
        abort('No unmerged commits found.')

    # Display unmerged commits in dev branch
    display_unmerged_commits(g, dev_branch)

    # Show commit style errors
    if not skip_style_check:
        display_commit_style_errors(g, dev_branch)


def main():

    # Parse arguments
    parser = argparse.ArgumentParser(
        description='Automate merging of feature branches.')

    parser.add_argument('dev_branch', metavar='dev_branch', type=str,
                        help='feature branch to merge')
    parser.add_argument('--check', action='store_true', default=False)
    parser.add_argument('--skip-style-check', action='store_true')
    parser.add_argument('--skip-pr-check', action='store_true')
    parser.add_argument('--delete-local', action='store_true', default=False)

    args = parser.parse_args()

    # Attempt to load configuration file
    config_filename = '.smush.yml'
    try:
        config = load_config(config_filename)
    except:
        abort('Unable to load ~/{}: does it exist?'.format(config_filename))

    # Verify QA branch has been set in the config file
    if 'qa branch' not in config:
        abort('Please set "qa branch" in {}.'.format(config_filename))

    # Set QA branch name from config
    qa_branch = config['qa branch']

    # Make sure command's being executed in a Git repository
    try:
        git.Repo('.').git_dir
        g = git.cmd.Git('.')
    except:
        abort('You must be in a git repository to run this command.')

    # Check branch and exit, if in --check mode
    if args.check:
        checkout_qa_branch_and_check_dev_branch(g, qa_branch, args.dev_branch, args.skip_style_check)
        sys.exit(0)

    # Show "before notes" from config, if any
    if 'before notes' in config:
        print(config['before notes'])

    # Make sure an open pull request exists for the dev branch
    if 'github owner' in config and 'github repo' in config and not args.skip_pr_check:
        if not check_if_open_pull_request_exists_for_branch(config['github owner'], config['github repo'], args.dev_branch):
            abort('There is no open pull request for this branch.')

    # Make sure QA branch is up to date
    print('Checking out QA branch...')
    g.checkout(qa_branch)
    print('Updating QA branch...')
    g.pull('--rebase')

    # Rebase dev branch
    print('Checking out dev branch..')
    g.checkout(args.dev_branch)
    print('Updating dev branch with work from QA...')
    g.rebase(qa_branch)

    # Push rebased version (so it'll get marked as merged later if on
    # Github)
    print('Pushing updated dev branch...')
    g.push('--force')

    # Do actual merge (with fast forward option as dev branch is rebased)
    print('Checking QA branch...')
    checkout_qa_branch_and_check_dev_branch(g, qa_branch, args.dev_branch)

    # Merge or abort
    if not get_confirmation('Would you like to merge the above commits?'):
        g.checkout(args.dev_branch)
        abort('Merge aborted.')

    print('Merging dev branch...')
    g.merge('--ff-only', args.dev_branch)

    # Push merge and delete dev branch
    print('Pushing QA branch with dev branch merged...')
    g.push()
    print('Deleting dev branch...')
    g.push('origin', ':{}'.format(args.dev_branch))

    # Optionally delete local dev branch
    if args.delete_local:
        print('Deleting local dev branch.')
        g.branch('-D', args.dev_branch)

    print('Done!')

    # Show "after notes" from config, if any
    if 'after notes' in config:
        print(config['after notes'])


if __name__ == '__main__':
    main()
